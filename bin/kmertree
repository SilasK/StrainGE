#!/usr/bin/env python
import sys
import argparse
import csv
import random
import re
import string
from itertools import combinations
import kmertools
import kmerizer
import numpy as np
import pydot

treeNodeCount = 0

class KmerTreeNode:
    def __init__(self, kmers, name = None, children = []):
        if name is not None:
            self.name = name
        else:
            self.name = "node-" + str(treeNodeCount)
        self.kmers = kmers
        self.counts = None
        self.children = children

    def isLeaf(self):
        return not self.children

    def label(self):
        s = str(self.kmers)
        if not self.isLeaf():
            s += " " + self.name
        return s

    def nwk(self):
        if self.isLeaf():
            return self.name
        else:
            return "(" + ",".join([c.nwk() for c in self.children]) + ")"


def getScore(nodePair, scores):
    if nodePair in scores:
        score = scores[nodePair]
    else:
        node1, node2 = nodePair
        k1 = node1.kmers
        k2 = node2.kmers
        score = kmertools.similarityScore(k1, k2)
        scores[nodePair] = score
    return score

def similarityScores(tree, scores):
    # calculate the intersection stats of kmers for all tree node pairs
    pairScores = [(pair, getScore(pair, scores)) for pair in combinations(tree, 2)]
    pairScores.sort(lambda a, b: cmp(b[1], a[1]))
    return pairScores

def newTreeNode(children):
    """
    Make a new node, propagating up the kmers in common among the children, leaving the children with
    their kmers not in common.
    :param children: child nodes
    :return: the new node
    """
    intersection = reduce(lambda x, y: np.intersect1d(x.kmers, y.kmers, assume_unique=True), children)
    node = KmerTreeNode(intersection, children=children)
    for child in children:
        child.kmers = np.setdiff1d(child.kmers, intersection, assume_unique=True)
    return node


def buildTree(tree, scores):
    pairScores = similarityScores(tree, scores)
    closePair, score = pairScores[0]
    newNode = newTreeNode(closePair)
    newTree = [x for x in tree if x not in closePair]
    newTree.append(newNode)
    print "%.3f" % score,
    return newTree



def graphTree(graph, tree, parentNode, vsSample = None):
    leaf = tree.isLeaf()
    nodeLabel = tree.label()
    color = 1
    textcolor = 9
    id = ''.join([random.choice(string.ascii_letters) for _ in xrange(8)])
    if type(vsSample) != type(None) and tree.kmers.size > 0:
        common = kmerizer.count_common(tree.kmers, vsSample)
        #nodeLabel = str(common) + "/" + nodeLabel
        frac = float(common) / tree.kmers.size
        nodeLabel = "%.1f%%\n%s" % (100.0 * frac, nodeLabel)
        color = int(round(frac * 8.0)) + 1
        if color >= 7: textcolor = 1
    node = pydot.Node(id, label=nodeLabel, style="filled", colorscheme='blues9', fillcolor=color, fontcolor=textcolor)
    graph.add_node(node)
    if parentNode:
        graph.add_edge(pydot.Edge(parentNode, node))
    if not leaf:
        for child in tree.children:
            graphTree(graph, child, node, vsSample)



def gatherKmers(node):
    if node.isLeaf():
        return [node.kmers]
    else:
        return [kmers for child in node.children for kmers in gatherKmers(child)] + [node.kmers]

def dedupeTree(tree):
    def dedupe(node, unique):
        node.kmers = np.intersect1d(node.kmers, unique, assume_unique=True)
        for child in node.children:
            dedupe(child, unique)
        return

    def simplifyTree(node, parent = None):
        # first simplify tree below us
        for child in node.children:
            simplifyTree(child, node)
        # adopt grandchildren where our child is dead
        deadChildren = [child for child in node.children if child.kmers.size == 0 and not child.isLeaf()]
        grandChildren = [grandChild for child in deadChildren for grandChild in child.children]
        for child in deadChildren:
            node.children.remove(child)
        node.children += grandChildren

    print 'Deduping:',
    kmerList = gatherKmers(tree)
    allKmers = np.concatenate(kmerList)
    print allKmers.size, 'kmers,',
    distinctKmers = np.unique(allKmers, return_counts = True)
    print distinctKmers[0].size, 'distinct,',
    uniqueKmers = distinctKmers[0][distinctKmers[1] == 1]
    print uniqueKmers.size, 'unique'
    dedupe(tree, uniqueKmers)
    simplifyTree(tree)


def countTree(tree):

    def setCounts(node, allKmers, allCounts):
        OFFSET = 1000000000
        print 'setCounts', node.name
        counts = np.empty(node.kmers.size, dtype=np.int64)
        counts = OFFSET
        merged = kmerizer.merge_counts(node.kmers, counts, allKmers, allCounts)
        mine = merged[1] >= OFFSET
        node.kmers = node.kmers[mine]
        node.counts = merged[1][mine]
        node.counts -= OFFSET
        for child in node.children:
            setCounts(child, allKmers, allCounts)
        return

    print 'Setting node kmer counts',
    kmerList = gatherKmers(tree)
    allKmers = np.concatenate(kmerList)
    distinctKmers = np.unique(allKmers, return_counts=True)
    setCounts(tree, distinctKmers[0], distinctKmers[1])


def treeFromNWK(nwkFile, nodes):
    nwk = open(nwkFile, 'r')
    quoted = re.sub(r'([^();,]+)', '"\\1"', nwk.read().strip().replace(";", ""))
    nwk.close()
    treeStructure = eval(quoted)

    nodesByName = {node.name: node for node in nodes}

    def makeTree(node):
        if type(node) == str:
            return nodesByName[node]
        else:
            children = [makeTree(child) for child in node]
            return newTreeNode(children)

    return makeTree(treeStructure)


def loadLeafNode(fileName, fingerprint):
    name = kmertools.nameFromPath(fileName)
    kset = kmertools.KmerSet()
    if args.fingerprint:
        kset.kmers = kmertools.loadFingerprint(arg)
    else:
        kset.kmers = kmertools.loadKmers(arg)
    return KmerTreeNode(kset.kmers, name=name)

###
### Main
###

parser = argparse.ArgumentParser()
parser.add_argument("--verbose", help="increase output verbosity",
                    action="store_true")
parser.add_argument("--fingerprint", help="use minhash fingerprint instead of full kmer set to build graph",
                    action="store_true")
parser.add_argument("--dedupe", action="store_true", help="Remove duplicate kmers from tree")
parser.add_argument("--nwk", help="File to receive NWK format tree")
parser.add_argument("--input", help="HDF5 tree input file")
parser.add_argument("--output", help="HDF5 tree output file")
parser.add_argument("--dot", help="File to receive graphviz dot-style tree graph")
parser.add_argument("--sample", help="test coverage of tree vs kmers in this sample npz")
parser.add_argument("--similarity", help="Similarity score output file")
parser.add_argument('genomes', nargs='+',
                    help='kmerized genome hdf5 or npz files')
args = parser.parse_args()

nodes = [loadLeafNode(arg, args.fingerprint) for arg in args.genomes]
nleaves = len(nodes)
print 'Loaded', nleaves, 'genomes'

intersections = {}

if args.similarity:
    print 'Computing pairwise similarity'
    stats = similarityScores(nodes, intersections)
    with open(args.similarity, "w") as simFile:
        csvwriter = csv.writer(simFile, delimiter="\t", lineterminator="\n")
        for stat in stats:
            (pair, score) = stat
            csvwriter.writerow([pair[0].name, pair[1].name, "%.5f" % score])

if not args.dot and not args.nwk:
    print 'No tree output...exiting!'
    sys.exit(0)

if args.input:
    print 'Generating kmer tree from', args.input
    tree = treeFromNWK(args.input, nodes)
else:
    while len(nodes) > 1:
        nodes = buildTree(nodes, intersections)
        print len(nodes)
        sys.stdout.flush()
    tree = nodes[0]

countTree(tree)

if args.dedupe:
    dedupeTree(tree)

if args.sample:
    sampleKmers = kmertools.loadKmers(args.sample)
else:
    sampleKmers = None

if args.dot:
    graph = pydot.Dot(graph_type='graph', rankdir='LR')
    graphTree(graph, tree, None, sampleKmers)
    graph.write_png(args.dot)

if args.nwk:
    with open(args.nwk, 'w') as nwk:
        print >>nwk, tree.nwk() + ';'
