#!/usr/bin/env python
import sys
import argparse
import time
import numpy as np
import kmertools
import kmerizer
import math
import h5py


parser = argparse.ArgumentParser()
parser.add_argument("-f", "--fingerprint", help="use minhash fingerprint instead of full kmer set to build graph",
                    action="store_true")
parser.add_argument("-v", "--verbose", action='store_true', help="More output")
parser.add_argument("-K", type=int, default=kmertools.DEFAULT_K, help="Kmer size")
parser.add_argument("-o", "--output", help="output text file")
parser.add_argument("-i", "--iterations", type=int, default=2, help="how many strains to look for")
parser.add_argument("-t", "--top", type=int, default=5, help="How many best matches to print")
parser.add_argument("-r", "--readlength", type=int, default=101, help="Read length (for better coverage estimates)")
parser.add_argument("pan", help="hdf5 file containing pan genome kmer set")
parser.add_argument("sample", help="Compare similarity of this vs the other strains instead of all vs all")
args = parser.parse_args()

# coverage normalization factor
covmult = float(args.readlength) / float(args.readlength - args.K + 1)

print "Loading sample", args.sample
sample = kmertools.kmerSetFromFile(args.sample)

exclude = None

with h5py.File(args.pan, 'r') as h5:
    print "Loading pan genome"
    pan = kmertools.KmerSet()
    pan.load_hdf5(h5)

    # common kmers contains all kmers of sample which are in pangenome
    panSampleKmers = kmerizer.intersect(sample.kmers, pan.kmers)
    print panSampleKmers.size, "pan kmers in sample"
    # how often each common kmer occurs in sample
    panSampleCounts = kmerizer.intersect_counts(sample.kmers, sample.counts, panSampleKmers)
    # how often each common kmer occurs in pangenome
    samplePanCounts = kmerizer.intersect_counts(pan.kmers, pan.counts, panSampleKmers)
    assert panSampleKmers.size == panSampleCounts.size == samplePanCounts.size, "Intersection kmers & counts differ in size"

    # release sample from memory
    sample = None

    for i in range(args.iterations):
        print "Finding strain", i + 1
        results = []
        bestScore = 0
        bestKset = None

        # loop over strains in pangenome file
        for name in h5.keys():
            # Strain KmerSets are in groups
            if not isinstance(h5[name], h5py.Group):
                continue

            strain = kmertools.KmerSet()
            strain.load_hdf5(h5[name])

            t0 = time.time()

            if args.fingerprint:
                strainKmers = strain.fingerprint
                strainCounts = np.ones_like(strain.fingerprint, dtype=np.int64)
            else:
                strainKmers = strain.kmers
                strainCounts = strain.counts

            if exclude is not None:
                keepers = np.setdiff1d(strainKmers, exclude, assume_unique=True)
                if float(keepers.size) / float(strainKmers.size) < 0.05:
                    break
                strainCounts = kmerizer.intersect_counts(strainKmers, strainCounts, keepers)
                strainKmers = keepers

            t1 = time.time()

            strainSampleKmers = kmerizer.intersect(panSampleKmers, strainKmers)
            if strainSampleKmers.size == 0:
                continue
            strainSampleCounts = kmerizer.intersect_counts(panSampleKmers, panSampleCounts, strainKmers)
            strainSampleCount = strainSampleCounts.sum()
            sampleStrainCounts = kmerizer.intersect_counts(strainKmers, strainCounts, panSampleKmers)
            sampleStrainCount = sampleStrainCounts.sum()
            assert strainSampleKmers.size == strainSampleCounts.size == sampleStrainCounts.size, "length mismatch"

            # Fraction of strain kmers in sample
            covered = float(strainSampleKmers.size) / float(strainKmers.size)
            # kmer coverage: mean coverage of every strain kmer that is in the sample
            kcoverage = float(strainSampleCount) / float(strainSampleKmers.size)
            # genome coverage: mean coverage of every strain kmer
            gcoverage = covmult * float(strainSampleCount) / float(strainCounts.sum())

            # converse of covered: what fraction of pangenome sample kmers are in this strain?
            accounted = float(strainSampleKmers.size) / float(panSampleKmers.size)

            t2 = time.time()

            # Lander-Waterman estimate of percentage covered if uniform
            estCovered = 1.0 - math.exp(-gcoverage)
            # measure of evenness of coverage
            evenness = covered / estCovered

            # # Weights of each kmer in strain
            # strainWeights = 1.0 / kmerizer.intersect_counts(pan.kmers, pan.counts, strainKmers)
            # sampleWeights = 1.0 / kmerizer.intersect_counts(pan.kmers, pan.counts, panSampleKmers)
            # # strainWeights = strainWeights * strainWeights
            # assert strainWeights.size == strainKmers.size, "Strain has kmers not in pan genome"
            # # Total weight of strain
            # strainWeight = (strainWeights * strainCounts).sum()
            # weights = 1.0 / kmerizer.intersect_counts(panSampleKmers, samplePanCounts, strainKmers)
            # assert strainSampleKmers.size == weights.size, "kmers/weights mismatch"
            #
            # # weighted coverage: sample coverage weighted by inverse kmer occurance in pan genome
            # countweight = (strainSampleCounts * weights).sum()
            # wcoverage = covmult * countweight / strainWeight
            # wsample = countweight / (1.0 / samplePanCounts).sum()
            #
            # specificity = wcoverage / gcoverage if gcoverage > wcoverage else gcoverage / wcoverage

            score = covered * accounted * evenness

            t3 = time.time()
            # print 'Times:', t1-t0, t2-t1, t3-t2

            result = (name, covered, kcoverage, gcoverage, accounted, evenness, score)
            results.append(result)

            if score > bestScore:
                bestScore = score
                bestKmers = strainSampleKmers
            if args.verbose:
                print "%32s cov %.3f kcov %.2f gcov %.2f acct %.3f even %.3f score %.3f" % result

        # print name, "covered: %.3f kcov: %.2f gcov: %.2f wcov: %.2f score: %.3f" % (covered, kcoverage, gcoverage, wcoverage, score)
        results.sort(lambda a, b: cmp(b[-1], a[-1]))
        for r in results[:args.top]:
            print "%32s cov %.3f kcov %.2f gcov %.2f acct %.3f even %.3f score %.3f" % r
        sys.stdout.flush()
        if exclude is None:
            exclude = bestKmers
        else:
            exclude, ignore = kmerizer.merge_counts(exclude, np.ones_like(exclude), bestKmers, np.ones_like(bestKmers))
        newKmers = np.setdiff1d(panSampleKmers, exclude, assume_unique=True)
        panSampleCounts = kmerizer.intersect_counts(panSampleKmers, panSampleCounts, newKmers)
        samplePanCounts = kmerizer.intersect_counts(panSampleKmers, samplePanCounts, newKmers)
        panSampleKmers = newKmers
        print panSampleKmers.size, "pan kmers in sample after excluding prior strain"

