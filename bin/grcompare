#!/usr/bin/env python
import os
import re
import itertools
import argparse
import numpy as np

import grtools

info_line = re.compile(r'##INFO=<ID=([A-Za-z0-9]+),Number=([0-9]+|\.),Type=(\w+),Description="(.*)">')
filter_line = re.compile(r'##FILTER=<ID=([A-Za-z0-9]+),Description="(.*)">') 

# globals
# min_confirm = None
# consensus = None
# verbose = False

class VCF:
    def __init__(self, name=None, reference=None, source=None, date=None):
        self.name = name
        self.reference = reference
        self.source = source
        self.date = date
        self.info = {}
        self.filters = {}
        self.data = {}
        self.positions = 0
        self.passed = 0
        self.confirmed = 0
        self.snps = 0
    
    def add(self, line):
        temp = line.strip().split("\t")
        chrom = temp[0]
        pos = int(temp[1])
        id = temp[2]
        ref = temp[3]
        alt = temp[4]
        if temp[5] != '.':
            qual = int(temp[5])
        else:
            qual = 0
        filt = temp[6]
        if filt != "PASS" and filt not in self.filters:
            print "Unknown filter", filt
            return
        inf = temp[7]
        info = {}
        for pair in inf.split(';'):
            key, value = pair.split('=')
            if key not in self.info:
                print "Unknown info key", key
                continue
            
            number = self.info[key]['Number']
            _type = self.info[key]['Type']
            if _type == 'Float':
                convert = float
            elif _type == 'Integer':
                convert = int
            else:
                convert = str
            if number == '1':
                info[key] = convert(value)
            else:
                _value = [convert(v) for v in value.split(",")]
                info[key] = _value
        
        if chrom not in self.data:
            self.data[chrom] = {}
        
        if pos in self.data[chrom]:
            print "Warning: position %s, %d found more than once" % (chrom, pos)
        else:
            self.positions += 1
        
        self.data[chrom][pos] = { 'ref': ref, 'alt': alt, 'qual': qual, 'filter': filt, 'info': info }
        if filt == 'PASS':
            self.passed += 1
            if alt == '.':
                self.confirmed += 1
            else:
                self.snps += 1
        else:
            self.filters[filt]['count'] += 1
    
    def get_confirmed(self):
        confirmed = []
        for chrom in sorted(self.data):
            for pos in sorted(self.data[chrom]):
                if self.data[chrom][pos]['filter'] == 'PASS' and self.data[chrom][pos]['alt'] == '.':
                    confirmed.append( (chrom, pos, None) )
        
        return confirmed
    
    def get_snps(self):
        snps = []
        for chrom in sorted(self.data):
            for pos in sorted(self.data[chrom]):
                if self.data[chrom][pos]['filter'] == 'PASS' and self.data[chrom][pos]['alt'] != '.':
                    snps.append( (chrom, pos, self.data[chrom][pos]['alt']) )
        return snps
    
    def get_ambiguous(self):
        amb = []
        for chrom in sorted(self.data):
            for pos in sorted(self.data[chrom]):
                if self.data[chrom][pos]['filter'] == 'amb':
                    amb.append( (chrom, pos, self.data[chrom][pos]['alt']) )
        return amb
    
    def __len__(self):
        return self.positions
    
    def __str__(self):
        return "VCF <source=%s reference=%s %d info %d filters %d chromosomes %d positions>" % (self.source, self.reference, len(self.info), len(self.filters), len(self.data), self.positions)

def parse_vcf_file(file):
    vcf = VCF(name=os.path.basename(file))
    with open(file, 'rb') as f:
        for line in f:
            if line[0] == '#':
                if line[1] == '#':
                    if 'fileDate' in line:
                        vcf.date = line.strip().split('=')[1]
                    elif 'source' in line:
                        vcf.source = line.strip().split('=')[1]
                    elif 'reference' in line:
                        vcf.reference = line.strip().split('=')[1]
                    elif '##INFO' in line:
                        temp = info_line.match(line)
                        if not temp:
                            print "Invalid info line", line
                            continue
                        (id, number, type, description) = temp.groups()
                        vcf.info[id] = {'Number': number, 'Type': type, 'Description': description}
                    elif '##FILTER' in line:
                        temp = filter_line.match(line)
                        if not temp:
                            print "Invalid filter line", line
                            continue
                        (id, description) = temp.groups()
                        vcf.filters[id] = {'description': description, 'count': 0}
                    else:
                        pass
                        #print "Unknown line!", line
                else:
                    # header def line
                    header = line.strip().split("\t")
                    if header[:8] != ['#CHROM', 'POS', 'ID', 'REF', 'ALT', 'QUAL', 'FILTER', 'INFO']:
                        print "Invalid header line!", line
                        return
            else:
                vcf.add(line)
    
    return vcf


def get_overlapping_pos(v1, v2, exact=True):
    if exact:
        return sorted(list(set(v1).intersection(v2)))
    
    # this assumes chrom and pos are sorted...
    overlap = []
    j = 0
    for (chrom, pos, alt) in v1:
        # reached end of v2
        if j >= len(v2):
            break
        # v1 chrom comes before v2 chrom
        if v2[j][0] > chrom:
            continue
        # chrom are == but v1 pos comes before v2 pos
        if v2[j][0] == chrom and v2[j][1] > pos:
            continue
        # v2 chrom comes before v1 chrom
        if v2[j][0] < chrom:
            j += 1
        # v2 chrom == v1 chrom but v2 pos before v1 pos
        elif v2[j][0] == chrom and v2[j][1] < pos:
            j += 1
        # get here only if chrom and pos ==
        else:
            overlap.append((chrom, pos, alt, v2[j][2]))
    
    return overlap



def compare_vcf_files(vcfs):
    # get snps and amb calls for each vcf
    refs = {}
    confirmed = {}
    snps = {}
    ambs = {}
    for vcf in vcfs:
        refs[vcf.name] = vcf.reference
        confirmed[vcf.name] = vcf.get_confirmed()
        snps[vcf.name] = vcf.get_snps()
        ambs[vcf.name] = vcf.get_ambiguous()
    
    # for each pair of vcf
    comps = {}
    for (v1, v2) in itertools.combinations(snps.keys(), 2):
        print "Comparing %s to %s" % (v1, v2)
        if refs[v1] != refs[v2]:
            print "Different references", refs[v1], refs[v2]
            continue
        # get overlapping confirmed positions
        overlap_confirmed = get_overlapping_pos(confirmed[v1], confirmed[v2], exact=True)
        # get identical snps between them
        overlap_snps = get_overlapping_pos(snps[v1], snps[v2], exact=True)
        # also get overlap of amb calls (check for alt alleles)
        # TODO: check exact match... or top match..., or just the set (forget ranking)
        # TODO: use Allele frequencies
        overlap_ambs = get_overlapping_pos(ambs[v1], ambs[v2], exact=False)
        # and finally look for overlap of snps and amb between pair
        overlap_nonref = sorted(get_overlapping_pos(snps[v1], ambs[v2], exact=False)+get_overlapping_pos(ambs[v1], snps[v2], exact=False))

        # look for signals that conflict b/w samples (SNP in one and REF in other)
        conflicts = sorted(get_overlapping_pos(snps[v1], confirmed[v2], exact=False)+get_overlapping_pos(confirmed[v1], snps[v2], exact=False))

        # report % overlap somehow...
        print "Overlapping confirmed reference positions:", len(overlap_confirmed)
        total = len(overlap_snps) + len(overlap_ambs) + len(overlap_nonref)
        print "Total overlapping non-reference positions shared:", total
        print "Exact SNPs overlapping:", len(overlap_snps)
        print "Ambiguous calls overlapping:", len(overlap_ambs)
        print "Non-reference positions shared:", len(overlap_nonref)
        print "Conflicting evidence (SNP in one, REF in other):", len(conflicts)
        comps[(v1, v2)] = (len(overlap_confirmed), len(overlap_snps), len(overlap_ambs), len(overlap_nonref), len(conflicts))
    
    return comps


def easy_compare(s1, s2):
    """Compare two samples from same reference"""
    i = 0
    confirmed = 0
    snps = 0
    ambs = 0
    non_refs = 0
    conflicts = 0
    for scaffold in s1.pileups:
        if scaffold not in s2.pileups:
            continue
        for pos in s1.pileups[scaffold]:
            if pos not in s2.pileups[scaffold]:
                continue # not found in 2
            elif not s1.pileups[scaffold][pos].covered():
                continue # not covered in 1
            elif not s2.pileups[scaffold][pos].covered():
                continue # not covered in 2
            elif s1.pileups[scaffold][pos].confirmed():
                if s2.pileups[scaffold][pos].confirmed():
                    confirmed += 1 # ref in both
                elif s2.pileups[scaffold][pos].base_call():
                    conflicts += 1 # ref in 1, snp in 2
            elif s1.pileups[scaffold][pos].base_call():
                if s2.pileups[scaffold][pos].confirmed():
                    conflicts += 1 # snp in 1, ref in 2
                elif s1.pileups[scaffold][pos].base_call() == s2.pileups[scaffold][pos].base_call():
                    snps += 1 # snp in both and same snp
                else:
                    non_refs += 1 # snp in 1 but amb in 2
            else:
                if s2.pileups[scaffold][pos].base_call():
                    non_refs += 1 # amb in 1, snp in 2
                elif not s1.pileups[scaffold][pos].confirmed():
                    ambs += 1 # amb in both
    

    total = confirmed + snps + amb + non_ref + conflicts
    print "Total positions analyzed:", total
    print "Reference confirmed in both", confirmed, float(confirmed)/total*100, '%'
    print "SNP confirmed in both", snps, float(snps)/total*100, '%'
    print "Ambiguous calls in both", ambs, float(ambs)/total*100, '%'
    print "Other non-reference calls in both", non_refs, float(non_refs)/total*100, '%'
    print "Conflicting evidence between samples", conflicts, float(conflicts)/total*100, '%'

    return (confirmed, snps, ambs, non_refs, conflicts)


def ambiguous_to_refs(pileup1, pileup2):
    others1 = pileup1.sort_alts()
    others2 = pileup2.sort_alts()

    if len(others1) and len(others2):
        if others1[0] == pileup2.refbase and others2[0] == pileup1.refbase:
            if pileup1.ref_fraction() > 0.5:
                return "ref1_ref2_amb"
            elif pileup2.ref_fraction() > 0.5:
                return "ref2_ref1_amb"

    return "amb_problematic"
    



def compare_pileups(pileup1, pileup2):
    if pileup1.covered():
        if pileup2.covered():
            if pileup1.confirmed():
                if pileup2.confirmed():
                    if pileup1.refbase == pileup2.refbase:
                        return 'ref_confirmed'
                    else:
                        return 'diff_confirmed'
                else:
                    snp2 = pileup2.base_call()
                    if snp2:
                        if snp2 == pileup1.refbase:
                            return 'likely_ref1'
                        else:
                            return 'ref1_diff_snp2'
                    else:
                        return 'ref1_amb2'
            
            # pileup1 not ref confirmed
            else:
                snp1 = pileup1.base_call()
                if pileup2.confirmed():
                    if snp1:
                        if snp1 == pileup2.refbase:
                            return 'likely_ref2'
                        else:
                            return 'ref2_diff_snp1'
                    else:
                        return 'ref2_amb1'
                
                # pileup2 not ref confirmed
                else:
                    snp2 = pileup2.base_call()
                    if snp2:
                        if snp1:
                            if snp2 == snp1:
                                return 'same_snp'
                            else:
                                return 'diff_snp'
                        else:
                            return 'snp2_amb1'
                    else:
                        if snp1:
                            return 'snp1_amb2'
                        else:
                            return ambiguous_to_refs(pileup1, pileup2)

        # pileup1 covered, pileup2 not
        else:
            return 'ref1_covered'
    
    # pileup1 not covered
    else:
        if pileup2.covered():
            return 'ref2_covered'
        else:
            return 'uncovered'


def match_pileups(matching, ref1, ref2):
    results = {'unmatched1': [], 'unmatched2': []}
    matched = set()
    for (scaffold, refpos) in matching.keys():
        comparison = None
        # only one pileup matches between references
        if len(matching[(scaffold, refpos)]) == 1:
            scaffold2, refpos2 = matching[(scaffold, refpos)].keys()[0]
            comparison = compare_pileups(ref1.pileups[scaffold][refpos], ref2.pileups[scaffold2][refpos2])
        
        # more than one pileup matches
        else:
            top = max(matching[(scaffold, refpos)], key = lambda x: matching[(scaffold, refpos)][x])
            # there is a majority of one pileup
            if matching[(scaffold, refpos)][top] > 0.5 * sum(matching[(scaffold, refpos)].values()):
                scaffold2, refpos2 = top
                comparison = compare_pileups(ref1.pileups[scaffold][refpos], ref2.pileups[scaffold2][refpos2])
                matched.add((scaffold2, refpos2))

        if comparison:
            if comparison not in results:
                results[comparison] = []
            results[comparison].append((scaffold, refpos, scaffold2, refpos2))
            matched.add((scaffold2, refpos2))
        else:
            results['unmatched1'].append((scaffold, refpos))
    
    for scaffold2 in ref2.pileups:
        for refpos2 in ref2.pileups[scaffold2]:
            if (scaffold2, refpos2) not in matched:
                results['unmatched2'].append((scaffold2, refpos2))
    
    return results
        
def compare_read(matching, read, ref1, ref2):
    for pos in ref1.reads[read]:
        if pos not in ref2.reads[read]:
            continue
        (base, scaffold, refpos) = ref1.reads[read][pos]
        (scaffold2, refpos2) = ref2.reads[read][pos][1:]
        if (scaffold, refpos) not in matching:
            matching[(scaffold, refpos)] = {}
        if (scaffold2, refpos2) not in matching[(scaffold, refpos)]:
            matching[(scaffold, refpos)][(scaffold2, refpos2)] = 0
        matching[(scaffold, refpos)][(scaffold2, refpos2)] += 1

def compare_references(ref1, ref2):

    r1_reads = []
    r2_reads = []
    matching = {}
    for read in ref1.reads:
        if read not in ref2.reads:
            r1_reads.append(read)
            continue
        compare_read(matching, read, ref1, ref2)
    
    for read in ref2.reads:
        if read not in ref1.reads:
            r2_reads.append(read)
    
    return match_pileups(matching, ref1, ref2), r1_reads, r2_reads

def len2(data):
    if data == None:
        return 0
    else:
        return len(data)

parser = argparse.ArgumentParser()
parser.add_argument("--verbose", help="increase output verbosity", action="store_true")
parser.add_argument("-r", "--references", action='store_true', help="Compare between references (within samples)")
parser.add_argument("--minconfirm", type=int, help='minimum pileup quality sum to confirm reference or SNP')
parser.add_argument("--consensus", type=float, help='minimum fraction of read quality to confirm reference or SNP')
parser.add_argument('out', help='Output results to file')
parser.add_argument("file", nargs='+', help="file from straingr tool (vcf or pkl)")
args = parser.parse_args()

print "Will output results to", args.out

if args.verbose:
    verbose = grtools.verbose

if args.references:
    if args.minconfirm:
        min_confirm = grtools.min_confirm
    if args.consensus:
        consensus = grtools.consensus
    
    print "Comparing within samples between references"
    all_pileups = {}
    for pkl_file in args.file:
        print "Loading file", pkl_file
        all_pileups[pkl_file] = grtools.load_pileups(pkl_file)        

    line = "{ref1}\t{ref2}\t{confirmed}\t{snps}\t{ref1_mixed}\t{ref2_mixed}\t{ref1_ref}\t{ref2_ref}\t{ref1_un}\t{ref2_un}\t{ref1_reads}\t{ref2_reads}\t{other}\n"
    with open(args.out, 'wb') as w:
        #w.write("Reference1\tReference2\tConfirmed\tSNPs\tAmbiguous\tRef1\tRef2\tRef1Only\tRef2Only\tProblematic\tRef1Reads\tRef2Reads\tRef1Pileups\tRef2Pileups\n")
        w.write("Ref1\tRef2\tConfirmed\tSNPs\tRef1_mixed\tRef2_mixed\tRef1_ref\tRef2_ref\tRef1_unmatched\tRef2_unmatched\tRef1_reads\tRef2_reads\n")
        for (r1, r2) in itertools.combinations(all_pileups.keys(), 2):
            print "Comparing", r1, "to", r2
            comparison, r1_reads, r2_reads = compare_references(all_pileups[r1], all_pileups[r2])
            if comparison:
            confirmed = len2(comparisons.get('ref_confirmed'))
            snps = len2(comparisons.get('same_snp'))
            ref1_mixed = len2(comparisons.get('ref1_ref2_amb'))
            ref2_mixed = len2(comparisons.get('ref2_ref1_amb'))
            ref1_ref = len2(comparisons.get('likely_ref1'))
            ref2_ref = len2(comparisons.get('likely_ref2'))
            ref1_un = len2(comparisons.get('unmatched1'))
            ref2_un = len2(comparisons.get('unmatched2'))
            ref1_reads = len(r1_reads)
            ref2_reads = len(r2_reads)

                w.write(line.format(ref1=r1, ref2=r2, confirmed=confirmed, snps=snps, ref1_mixed=ref1_mixed, 
                                    ref2_mixed=ref2_mixed, ref1_ref=ref1_ref, ref2_ref=ref2_ref, ref1_un=ref1_un,
                                    ref2_un=ref2_un, ref1_reads=ref1_reads, ref2_reads=ref2_reads))

                # w.write('%s\t%s\t%s\n' % (s1, s2, '\t'.join([str(x) for x in comparison[1:]])))



else:
    vcfs = []
    for file in args.file:
        vcfs.append(parse_vcf_file(file))

    compare_vcf_files(vcfs)
