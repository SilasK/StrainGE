#!/usr/bin/env python
import os
import sys
import argparse
from collections import OrderedDict
import math
from multiprocessing import Pool
import numpy as np
import kmertools
import kmerizer
import h5py


parser = argparse.ArgumentParser()
parser.add_argument("-f", "--fingerprint", help="use minhash fingerprint instead of full kmer set to build graph",
                    action="store_true")
parser.add_argument("-v", "--verbose", action='store_true', help="More output")
parser.add_argument("-c", "--cache", action='store_true', help="Cache strain kmer sets between iterations (uses more memory)")
parser.add_argument("-K", type=int, default=kmertools.DEFAULT_K, help="Kmer size (default: %d)" % (kmertools.DEFAULT_K))
parser.add_argument("-o", "--output", help="output text file (default: standard out)")
parser.add_argument("-i", "--iterations", type=int, default=5, help="max strains to look for (default: 5)")
parser.add_argument("-t", "--top", type=int, default=1, help="How many best matches to print (default: 1)")
parser.add_argument("-s", "--score", type=float, default=0.005, help="minimum score")
parser.add_argument("-e", "--evenness", type=float, default=0.6, help="minimum evenness")
parser.add_argument("-S", "--scoring", choices=("default", "weighted"), default="default", help="scoring algorithm")
#parser.add_argument("-r", "--readlength", type=int, default=101, help="Read length (for better coverage estimates, default: 101)")
parser.add_argument("-p", "--threads", type=int, default=1, help="Parallel threads (implies --cache)")
parser.add_argument("pan", help="hdf5 file containing pan genome kmer set")
parser.add_argument("sample", help="Compare similarity of this vs the other strains instead of all vs all")
args = parser.parse_args()

cache = args.cache or args.threads > 1
# coverage normalization factor
#covmult = float(args.readlength) / float(args.readlength - args.K + 1)

strainKmerSets = {}

class Sample(kmertools.KmerSet):
    def __init__(self, hdf5file):
        self.name = kmertools.nameFromPath(hdf5file)
        print "Loading sample"
        self.hdf5file = hdf5file
        h5 = h5py.File(hdf5file, 'r')
        self.load_hdf5(h5)
        self.totalCount = self.counts.sum()
        print self.kmers.size, "distinct kmers,", self.totalCount, "total kmers in sample"


class PanGenome(kmertools.KmerSet):
    def __init__(self, hdf5file):
        self.hdf5file = hdf5file
        print "Loading pan genome"
        self.h5 = h5py.File(hdf5file, 'r')
        self.load_hdf5(self.h5)
        # Strains are groups within hdf5 file
        self.strainNames = [name for name in self.h5.keys() if isinstance(self.h5[name], h5py.Group)]
        print len(self.strainNames), "strains,", self.kmers.size, "kmers in pan genome"
        self.strainCache = {}

    def loadStrain(self, name):
        if name in self.strainCache:
            return strainCache[name]
        else:
            strain = Strain(self, name)
            self.strainCache[name] = strain
            return strain

    def scoreSample(self, sample):
        s = sample.intersect(self.kmers)
        sample.kmers = s.kmers
        sample.counts = s.counts
        print sample.kmers.size, "pan kmers in sample"
        results = map(lambda s: self.scoreStrain(s, sample), self.strainNames)

    def scoreStrain(self, strainName, sample):
        strain = self.loadStrain(strainName)
        return strain.scoreSample(sample)

    def processResults(self, results):
        results.sort(lambda a, b: cmp(b.score, a.score))
        print results[:3]


class Strain(kmertools.KmerSet):
    def __init__(self, pan, name):
        self.name = name
        self.load_hdf5(pan.h5[name])
        self.panCounts = kmerizer.intersect_counts(self.kmers, self.counts, pan.kmers)
        self.distinctKmers = self.kmers.size
        self.totalKmers = self.counts.sum()
        assert self.panCounts.size == self.distinctKmers, "Pan count intersection didn't match!"

    def exclude(self, excludeKmers):
        kset = super(Strain, self).exclude(excludeKmers)
        self.panCounts = kmerizer.intersect_counts(self.kmers, self.panCounts, kset.kmers)
        self.kmers = kset.kmers
        self.counts = kset.counts

    def scoreSample(self, sample, excludes = None):
        if excludes:
            self.exclude(excludes)

        # distinct kmers in this strain and sample
        kmers = kmerizer.intersect(self.kmers, sample.kmers)
        # how many times each occurred in this strain
        counts = kmerizer.intersect_counts(self.kmers, self.counts, kmers)
        # how many times each strain kmer occurred in pan genome (for weighting)
        panCounts = kmerizer.intersect_counts(self.kmers, self.panCounts, kmers)
        # how many times did each common kmers occurred in sample?
        sampleCounts = kmerizer.intersect_counts(sample.kmers, sample.counts, kmers)
        sampleCount = sampleCounts.sum()

        # Compute metrics
        # what fraction of the distinct kmers are in the sample?
        covered = float(kmers.size) / float(self.kmers.size)
        # for each distinct kmer in common, how many times did it occur in the sample relative to the strain?
        kmerCoverage = float(sampleCount) / float(counts.sum())
        # mean genome coverage from all my kmers
        genomeCoverage = float(sampleCount) / float(self.counts.sum())

        # converse of covered: what fraction of pan genome sample kmers are accounted for by this sample?
        accounted = float(kmers.size) / float(sample.kmers.size)
        # Lander-Waterman estimate of percentage covered if randomly distributed across genome
        estCovered = 1.0 - math.exp(-genomeCoverage)
        # measure of evenness of coverage
        evenness = covered / estCovered

        weights = counts * (1.0 / panCounts)
        weighted = (sampleCounts * weights).sum()
        totalWeight = (self.counts * (1.0 / self.panCounts)).sum()
        print weighted, totalWeight
        weightedCoverage = weighted / totalWeight
        specificity = weightedCoverage / genomeCoverage

        score = covered * evenness * accounted

        results = {"strainname": self.name,
                   "gkmers": self.totalKmers,
                   "xkmers": self.kmers.size,
                   "cov": covered,
                   "kcov": kmerCoverage,
                   "gcov": genomeCoverage,
                   "acct": accounted,
                   "even": evenness,
                   "wcov": weightedCoverage,
                   "spec": specificity,
                   "score": score}

        print self.name, results

        return results








def tabout(things, file=sys.stdout):
    """
    Print tab-separated sequence of things to line in file
    :param things: sequence of things
    :param file: output file
    """
    print >>file, "\t".join([str(x) for x in things])
    file.flush()

def scoreStrain(name):
    global excludeKmers, panSampleKmers, panSampleCounts
    strain = strainKmerSet(name)
    strainKmers = strain.kmers
    strainCounts = strain.counts

    # t0 = time.time()

    if args.fingerprint and excludeKmers is None:
        strainKmers = strain.fingerprint
        strainCounts = np.ones_like(strain.fingerprint, dtype=np.int64)

    if excludeKmers is not None:
        strainKmers = kmerizer.diff(strain.kmers, excludeKmers)
        if float(strainKmers.size) / float(strain.kmers.size) < 0.05:
            return
        strainCounts = kmerizer.intersect_counts(strain.kmers, strain.counts, strainKmers)

    strainSampleKmers = kmerizer.intersect(panSampleKmers, strainKmers)
    if strainSampleKmers.size == 0:
        return
    strainSampleCounts = kmerizer.intersect_counts(panSampleKmers, panSampleCounts, strainKmers)
    strainSampleCount = strainSampleCounts.sum()
    sampleStrainCounts = kmerizer.intersect_counts(strainKmers, strainCounts, panSampleKmers)
    sampleStrainCount = sampleStrainCounts.sum()
    assert strainSampleKmers.size == strainSampleCounts.size == sampleStrainCounts.size, "length mismatch"

    # Fraction of strain kmers in sample
    covered = float(strainSampleKmers.size) / float(strainKmers.size)
    # kmer coverage: mean coverage of every strain kmer that is in the sample
    kcoverage = float(strainSampleCount) / float(strainSampleKmers.size)
    # genome coverage: mean coverage of every strain kmer
    gcoverage = float(strainSampleCount) / float(strainCounts.sum())

    # converse of covered: what fraction of pangenome sample kmers are in this strain?
    accounted = float(strainSampleKmers.size) / float(panSampleKmers.size)

    # t2 = time.time()

    # Lander-Waterman estimate of percentage covered if uniform
    estCovered = 1.0 - math.exp(-gcoverage)
    # measure of evenness of coverage
    evenness = covered / estCovered

    result = {"strainname": name,
              "gkmers": strain.kmers.size,
              "xkmers": strainKmers.size,
              "cov": covered,
              "kcov": kcoverage,
              "gcov": gcoverage,
              "acct": accounted,
              "even": evenness}

    # Weights of each kmer in strain (inverse of occurrence in pangenome)
    strainPanCounts = kmerizer.intersect_counts(pan.kmers, pan.counts, strainKmers)
    strainWeights = 1.0 / strainPanCounts
    strainTotalWeight = (strainWeights * strainCounts).sum()

    strainSampleWeights = 1.0 / kmerizer.intersect_counts(strainKmers, strainPanCounts, strainSampleKmers)
    countweight = (strainSampleCounts * strainSampleWeights).sum()
    wcoverage = countweight / strainTotalWeight
    # wsample = countweight / (1.0 / samplePanCounts).sum()
    #
    specificity = wcoverage / gcoverage
    result["spec"] = specificity
    #score = covered * accounted * min(specificity, 1 / specificity)
    score = covered * accounted * evenness
    result["score"] = score

    return result


resultFormats = OrderedDict([("i", "%d"),
                             ("strainname", "%s"),
                             ("gkmers", "%d"),
                             ("xkmers", "%d"),
                             ("cov", "%.3f"),
                             ("kcov", "%.2f"),
                             ("gcov", "%.2f"),
                             ("acct", "%.3f"),
                             ("even", "%.3f"),
                             ("spec", "%.2f"),
                             ("score", "%.3f")])


pan = PanGenome(args.pan)
sample = Sample(args.sample)
pan.scoreSample(sample)
exit(0)

print >>sys.stderr, "Loading sample", args.sample
sampleName = os.path.basename(args.sample)
if sampleName.endswith(".hdf5"):
    sampleName = sampleName[:-5]
sample = kmertools.kmerSetFromFile(args.sample)
sampleKmerTotal = sample.counts.sum()
print >>sys.stderr, "%.2e total kmers in sample" % (sampleKmerTotal,)

excludeKmers = None

if args.output:
    output = open(args.output, 'w')
else:
    output = sys.stdout

with h5py.File(args.pan, 'r') as h5pan:
    print >>sys.stderr, "Loading pan genome"
    pan = kmertools.KmerSet()
    pan.load_hdf5(h5pan)
    # Strains are groups within hdf5 file
    strainNames = [name for name in h5pan.keys() if isinstance(h5pan[name], h5py.Group)]
    print >>sys.stderr, len(strainNames), "strains,", pan.kmers.size, "kmers in pan genome"

    # common kmers contains all kmers of sample which are in pangenome
    panSampleKmers = kmerizer.intersect(sample.kmers, pan.kmers)
    print >>sys.stderr, panSampleKmers.size, "pan kmers in sample",
    # how often each common kmer occurs in sample
    panSampleCounts = kmerizer.intersect_counts(sample.kmers, sample.counts, panSampleKmers)
    panSampleCount = panSampleCounts.sum()
    panSampleKmerPct = 100.0 * panSampleCount / sampleKmerTotal
    panSampleKmerCov = float(panSampleCount) / panSampleKmers.size
    print >>sys.stderr, "(%.3f%%)" % (panSampleKmerPct,)
    # how often each common kmer occurs in pangenome
    samplePanCounts = kmerizer.intersect_counts(pan.kmers, pan.counts, panSampleKmers)
    assert panSampleKmers.size == panSampleCounts.size == samplePanCounts.size, "Intersection kmers & counts differ in size"
    if args.output:
        tabout(("samplename", "totalkmers", "distinct", "pkmers", "pkcov", "pan%"), output)
        tabout((sampleName, sampleKmerTotal, sample.kmers.size, panSampleKmers.size,
                round(panSampleKmerCov, 2), round(panSampleKmerPct, 3)), output)

    # release sample from memory
    sample = None

    if cache:
        # preload kmer sets
        print >>sys.stderr, "Loading strains"
        for s in strainNames:
            strainKmerSet(s)

    # print output header
    rKeys = [k for k in resultFormats] # if k != "spec" or args.scoring == "weighted"]
    rFormats = [resultFormats[k] for k in rKeys]
    tabout(rKeys, output)
    for i in range(args.iterations):
        print >>sys.stderr, "Finding strain", i + 1
        results = []
        bestScore = 0
        bestKset = None

        # loop over strains in pangenome file
        if args.threads > 1:
            pool = Pool(args.threads)
            results = pool.map(scoreStrain, strainNames)
            pool.terminate()
        else:
            results = map(scoreStrain, strainNames)


        results = list(filter(lambda r: r and r["score"] >= args.score and r["even"] >= args.evenness, results))

        if len(results) == 0:
            break

        for r in results:
            r["i"] = i

        results.sort(lambda a, b: cmp(b["score"], a["score"]))

        for r in results[:args.top]:
            rValues = tuple((r[k] for k in rKeys))
            tabout([fmt % value for fmt, value in zip(rFormats, rValues)], output)

        if args.output:
            output.flush()
        else:
            sys.stdout.flush()

        bestKmers = strainKmerSet(results[0]["strainname"]).kmers

        if excludeKmers is None:
            excludeKmers = bestKmers
        else:
            excludeKmers = np.unique(np.concatenate((excludeKmers, bestKmers)))
        #newKmers = np.setdiff1d(panSampleKmers, exclude, assume_unique=True)
        newKmers = kmerizer.diff(panSampleKmers, excludeKmers)
        #assert np.array_equal(newKmers, xxx), "kmerizer.diff bug"
        panSampleCounts = kmerizer.intersect_counts(panSampleKmers, panSampleCounts, newKmers)
        samplePanCounts = kmerizer.intersect_counts(panSampleKmers, samplePanCounts, newKmers)
        panSampleKmers = newKmers
        print >>sys.stderr, panSampleKmers.size, "pan kmers in sample after excluding prior strain"

print >>sys.stderr, 'Done!'

if args.output:
    output.close()