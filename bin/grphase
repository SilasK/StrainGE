#!/usr/bin/env python
"""Phase ambiguous calls (mixed evidence) from straingr results"""

import os
import argparse
import pysam
import networkx as nx
import grtools

class HaplotypeGraph:
    def __init__(self, reads=None):
        self.nodes = {}
        self.edges = {}
        self.graphs = {}
        self.paths = {}
        if reads:
            for read in reads:
                self.add_read(read)
    
    def add_read(self, read):
        prev = None
        for allele in read:
            scaffold = allele['scaffold']
            if scaffold not in self.nodes:
                self.nodes[scaffold] = {}
            if scaffold not in self.edges:
                self.edges[scaffold] = {}
            refpos = allele['refpos']
            base = allele['base']
            node = (refpos, base)

            if node not in self.nodes[scaffold]:
                self.nodes[scaffold][node] = 0
            self.nodes[scaffold][node] += 1
            
            if prev:
                edge = (prev, node)
                if edge not in self.edges[scaffold]:
                    self.edges[scaffold][edge] = 0
                self.edges[scaffold][edge] += 1
            
            prev = node
        
    
    def phase_haplotypes(self):
        if self.paths:
            print "Re-phasing haplotypes"
        
        self.paths = {}
        for scaffold in self.nodes:
            self.paths[scaffold] = {}
            graph = nx.DiGraph()
            for node in self.nodes[scaffold]:
                graph.add_node(node, count=self.nodes[scaffold][node])
            for edge in self.edges[scaffold]:
                graph.add_edge(*edge, weight=self.edges[scaffold][edge])
            self.graphs[scaffold] = graph

        

def phase_ambiguous_old(pileups):
    """Phase ambiguous pileups based on read information"""

    # only look for ambiguous pileups
    amb_pileups = {}
    for scaffold in pileups.pileups:
        for refpos in pileups.pileups[scaffold]:
            pileup = pileups.pileups[scaffold][refpos]
            if not pileup.covered():
                continue
            if pileup.confirmed():
                continue
            if pileup.base_call():
                continue
            if scaffold not in amb_pileups:
                amb_pileups[scaffold] = set()
            amb_pileups[scaffold].add(refpos) 
    
    phased_ambs = {}
    # loop through reads

    reads = set([read[:-2] for read in pileups.reads])

    for pair in reads:
        in_phase = []
        for i in xrange(1,3):
            read = "%s.%i" % (pair, i)
            if read not in pileups.reads:
                continue
            scaffold = pileups.reads[read]['scaffold']
            if scaffold not in amb_pileups:
                continue
            for pos in pileups.reads[read]:
                temp = pileups.reads[read]['pileups'][pos]
                refpos = temp['refpos']
                if refpos not in amb_pileups[scaffold]:
                    continue
                in_phase.append(dict(scaffold=scaffold, refpos=refpos, pos=pos,  mate=i, base=temp['base']))
        
        # look for in_phase ambiguous calls at more than one refpos
        if len(set([variant['refpos'] for variant in in_phase])) > 1:
            phased_ambs[pair] = in_phase
    
    return phased_ambs

def qc_read(read):
    alignment = read.alignment
    if (not alignment.is_paired) or (not alignment.is_proper_pair):
        return

    # restrict ourselves to full-length alignments (not clipped)
    if alignment.query_alignment_length != alignment.query_length:
        # alignment is clipped
        return

    # check that inferred insert size is at least read length
    tlen = alignment.template_length
    if abs(tlen) < alignment.query_length:
        return
    
    # check for decent mapping quality
    mq = alignment.mapping_quality
    if mq < grtools.min_mq:
        return
    
    # get base quality (note this is next base if deletion)
    pos = read.query_position_or_next
    qual = alignment.query_qualities[pos]
    if qual < grtools.min_qual:
        return

    # base call must be real base (e.g., not N)
    base = alignment.query_sequence[pos]
    if base not in grtools.bases:
        return

    return (alignment.query_name, alignment.is_read1, pos, base)

def phase_ambiguous(bamfile, amb_pileups):
    
    bam = pysam.AlignmentFile(bamfile, "rb")
    phased = {}
    for scaffold in bam.references:
        reads = {}
        if scaffold not in amb_pileups:
            continue
        for column in bam.pileup(scaffold):
            refpos = column.reference_pos
            if refpos not in amb_pileups[scaffold]:
                continue
            for read in column.pileups:
                temp = qc_read(read)
                if not temp:
                    continue
                (name, read1, pos, base) = temp
                if name not in reads:
                    reads[name] = {}
                position = (read1, pos)
                reads[name][position] = (refpos, base)
        for name in reads.keys():
            if len(reads[name]) > 1:
                phased[name] = []
                for position in reads[name]:
                    (read1, pos) = position
                    (refpos, base) = reads[name][position]
                    phased[name].append(dict(scaffold=scaffold, refpos=refpos, pos=pos, read1=read1, base=base))
            del reads[name]

    return phased        


def count_haplotypes(phased_ambs):
    pass

def write_text(phased_ambs, out):
    if not phased_ambs:
        return
    
    if not out:
        return
    line = '{pair}\t{mate}\t{scaffold}\t{refpos}\t{pos}\t{base}\n'
    with open(out, 'wb') as w:
        w.write("Read\tMate\tScaffold\tRefpos\tPos\tBase\n")
        for pair in sorted(phased_ambs):
            for result in sorted(phased_ambs[pair], key = lambda x: (x['refpos'])):
                scaffold = result['scaffold']
                refpos = result['refpos']
                pos = result['pos']
                if result['read1']:
                    mate = '1'
                else:
                    mate = '2'
                base = result['base']
                w.write(line.format(pair=pair, mate=mate, scaffold=scaffold, refpos=refpos, pos=pos, base=base))


# def phase_snps(pileups):
#     """Look for SNPs and ambiguous calls in phase"""

#     phased_snps = {}
    
#     # go through scaffolds
#     for scaffold in pileups.pileups:
#         # go through positions in scaffolds
#         scaf_pileups = pileups.pileups[scaffold]
#         for pos in sorted(scaf_pileups):
            
#             # if ambiguous
#             if not scaf_pileups[pos].hc and scaf_pileups[pos].covered() and not ( scaf_pileups[pos].confirmed() or scaf_pileups[pos].base_call() ):
#                 # loop through all reads in that pileup
#                 reads = scaf_pileups[pos].reads
#                 reads2 = {}
#                 for read in reads:
#                     if read[-2:] == '.1':
#                         read2 = read[-2:]+'.2'
#                     else:
#                         read2 = read[-2:]+'.1'
#                     if read2 in scaf_pileups[pos].reads:
#                         reads2[read] = read2
#                 for read in reads.keys():
#                     base1 = scaf_pileups[pos].reads[read][1]
#                     # loop through every position in that read
#                     for read_pos in sorted(pileups.reads[read]):
#                         # get pileup location for that position
#                         (scaffold2, pos2) = pileups.reads[read][read_pos]
#                         if scaffold2 != scaffold:
#                             print 'Read found on two scaffolds!'
#                             continue
#                         if pos2 <= pos:
#                             # don't look back
#                             continue
#                         # if this pileup also ambigous!
#                         if not scaf_pileups[pos2].hc and scaf_pileups[pos2].covered() and not (scaf_pileups[pos2].confirmed() or scaf_pileups[pos2].base_call()):

#                             if scaffold not in phased_snps:
#                                 phased_snps[scaffold] = {}
#                             if pos not in phased_snps[scaffold]:
#                                 phased_snps[scaffold][pos] = {}
                            
#                             if pos2 not in phased_snps[scaffold][pos]:
#                                 phased_snps[scaffold][pos][pos2] = {}
                            
#                             base2 = scaf_pileups[pos2].reads[read][1]
#                             if (base1, base2) not in phased_snps[scaffold][pos][pos2]:
#                                 phased_snps[scaffold][pos][pos2][(base1, base2)] = 0
#                             phased_snps[scaffold][pos][pos2][(base1, base2)] += 1
                    
#                     if read not in reads2:
#                         # paired read not in data
#                         continue
#                     read2 = reads2[read]
#                     # do this for the other paired read
#                     for read_pos in sorted(pileups.reads[read2]):
#                         # get pileup location for that position
#                         (scaffold2, pos2) = pileups.reads[read2][read_pos]
#                         if scaffold2 != scaffold:
#                             print 'Read found on two scaffolds!'
#                             continue
#                         if pos2 <= pos:
#                             # don't look back
#                             continue
#                         # if this pileup also ambigous!
#                         if not scaf_pileups[pos2].hc and scaf_pileups[pos2].covered() and not (scaf_pileups[pos2].confirmed() or scaf_pileups[pos2].base_call()):

#                             if scaffold not in phased_snps:
#                                 phased_snps[scaffold] = {}
#                             if pos not in phased_snps[scaffold]:
#                                 phased_snps[scaffold][pos] = {}
                            
#                             if pos2 not in phased_snps[scaffold][pos]:
#                                 phased_snps[scaffold][pos][pos2] = {}
                            
#                             base2 = scaf_pileups[pos2].reads[read2][1]
#                             if (base1, base2) not in phased_snps[scaffold][pos][pos2]:
#                                 phased_snps[scaffold][pos][pos2][(base1, base2)] = 0
#                             phased_snps[scaffold][pos][pos2][(base1, base2)] += 1

#     return phased_snps

# def write_text(phased_snps, out):
#     """Write phased snps to text"""

#     with open(out, 'wb') as w:
#         w.write("Scaffold\tPos1\tPos2\tCount\tBase1\tBase2\n")
#         for scaffold in sorted(phased_snps):
#             for pos1 in sorted(phased_snps[scaffold]):
#                 for pos2 in sorted(phased_snps[scaffold][pos1]):
#                     for (base1, base2) in sorted(phased_snps[scaffold][pos1][pos2]):
#                         count = phased_snps[scaffold][pos1][pos2][(base1, base2)]
#                         w.write('%s\t%i\t%i\t%i\t%s\t%s\n' % (scaffold, pos1, pos2, count, base1, base2))


parser = argparse.ArgumentParser()
# parser.add_argument("--verbose", help="increase output verbosity", action="store_true")
# parser.add_argument("--minconfirm", type=int, help='minimum pileup quality sum to confirm reference or SNP')
# parser.add_argument("--consensus", type=float, help='minimum fraction of reads to confirm reference or SNP')
parser.add_argument("-q", "--minqual", type=int, help='minimum base Quality score to consider')
parser.add_argument("-m", "--minmq", type=int, help='minimum read Mapping quality score to consider')
parser.add_argument("-o", "--out", help="Text output filename")
parser.add_argument("vcf", help="vcf file from straingr tool")
parser.add_argument("bamfile", help="BAM file used to generate vcf file (index & sorted)")
# parser.add_argument("pickle", help="pickle file from straingr tool")
args = parser.parse_args()

if args.minqual:
    grtools.min_qual = args.minqual
if args.minmq:
    grtools.min_mq = args.minmq

# if args.verbose:
#     verbose = args.verbose
# if args.minconfirm:
#     min_confirm = grtools.min_confirm
# if args.consensus:
#     consensus = grtools.consensus

# for pkl_file in args.file:
#     try:
#         print "Loading", pkl_file
#         pileups = grtools.load_pileups(pkl_file)
#         # print "Getting SNPs in phase"
#         print "Phasing ambiguous base calls"
#         # phased_snps = phase_snps(pileups)
#         phased_ambs = phase_ambiguous(pileups)
#         # out = '.'.join(pkl_file.split(".")[:-1])+'.phased_snps.tsv'
#         out = '.'.join(os.path.basename(pkl_file).split(".")[:-1])+'.phased_ambs.tsv'
#         print "Writing to", out
#         # write_text(phased_snps, out)
#         write_text(phased_ambs, out)
#     except KeyboardInterrupt:
#         break
#     except Exception as e:
#         print e


vcf = grtools.parse_vcf_file(args.vcf)

ambs = {}
for (scaffold, pos, _) in vcf.get_ambiguous():
    if scaffold not in ambs:
        ambs[scaffold] = set()
    ambs[scaffold].add(pos)

phased_ambs = phase_ambiguous(args.bamfile, ambs)

if args.out:
    write_text(phased_ambs, args.out)